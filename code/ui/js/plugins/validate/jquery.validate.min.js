!function (B) {
    "function" == typeof define && define.amd ? define(["jquery"], B) : B(jQuery)
}(function (E) {
    E.extend(E.fn, {
        validate: function (A) {
            if (!this.length) {
                return void (A && A.debug && window.console && console.warn("Nothing selected, can't validate, returning nothing."))
            }
            var B = E.data(this[0], "validator");
            return B ? B : (this.attr("novalidate", "novalidate"), B = new E.validator(A, this[0]), E.data(this[0], "validator", B), B.settings.onsubmit && (this.validateDelegate(":submit", "click", function (C) {
                B.settings.submitHandler && (B.submitButton = C.target), E(C.target).hasClass("cancel") && (B.cancelSubmit = !0), void 0 !== E(C.target).attr("formnovalidate") && (B.cancelSubmit = !0)
            }), this.submit(function (H) {
                function C() {
                    var G;
                    return B.settings.submitHandler ? (B.submitButton && (G = E("<input type='hidden'/>").attr("name", B.submitButton.name).val(E(B.submitButton).val()).appendTo(B.currentForm)), B.settings.submitHandler.call(B, B.currentForm, H), B.submitButton && G.remove(), !1) : !0
                }

                return B.settings.debug && H.preventDefault(), B.cancelSubmit ? (B.cancelSubmit = !1, C()) : B.form() ? B.pendingRequest ? (B.formSubmitted = !0, !1) : C() : (B.focusInvalid(), !1)
            })), B)
        }, valid: function () {
            var A, B;
            return E(this[0]).is("form") ? A = this.validate().form() : (A = !0, B = E(this[0].form).validate(), this.each(function () {
                A = B.element(this) && A
            })), A
        }, removeAttrs: function (C) {
            var A = {}, B = this;
            return E.each(C.split(/\s/), function (I, J) {
                A[J] = B.attr(J), B.removeAttr(J)
            }), A
        }, rules: function (B, C) {
            var M, P, R, A, N, O, Q = this[0];
            if (B) {
                switch (M = E.data(Q.form, "validator").settings, P = M.rules, R = E.validator.staticRules(Q), B) {
                    case"add":
                        E.extend(R, E.validator.normalizeRule(C)), delete R.messages, P[Q.name] = R, C.messages && (M.messages[Q.name] = E.extend(M.messages[Q.name], C.messages));
                        break;
                    case"remove":
                        return C ? (O = {}, E.each(C.split(/\s/), function (H, G) {
                            O[G] = R[G], delete R[G], "required" === G && E(Q).removeAttr("aria-required")
                        }), O) : (delete P[Q.name], R)
                }
            }
            return A = E.validator.normalizeRules(E.extend({}, E.validator.classRules(Q), E.validator.attributeRules(Q), E.validator.dataRules(Q), E.validator.staticRules(Q)), Q), A.required && (N = A.required, delete A.required, A = E.extend({required: N}, A), E(Q).attr("aria-required", "true")), A.remote && (N = A.remote, delete A.remote, A = E.extend(A, {remote: N})), A
        }
    }), E.extend(E.expr[":"], {
        blank: function (A) {
            return !E.trim("" + E(A).val())
        }, filled: function (A) {
            return !!E.trim("" + E(A).val())
        }, unchecked: function (A) {
            return !E(A).prop("checked")
        }
    }), E.validator = function (A, B) {
        this.settings = E.extend(!0, {}, E.validator.defaults, A), this.currentForm = B, this.init()
    }, E.validator.format = function (A, B) {
        return 1 === arguments.length ? function () {
            var C = E.makeArray(arguments);
            return C.unshift(A), E.validator.format.apply(this, C)
        } : (arguments.length > 2 && B.constructor !== Array && (B = E.makeArray(arguments).slice(1)), B.constructor !== Array && (B = [B]), E.each(B, function (H, C) {
            A = A.replace(new RegExp("\\{" + H + "\\}", "g"), function () {
                return C
            })
        }), A)
    }, E.extend(E.validator, {
        defaults: {
            messages: {},
            groups: {},
            rules: {},
            errorClass: "error",
            validClass: "valid",
            errorElement: "label",
            focusInvalid: !0,
            errorContainer: E([]),
            errorLabelContainer: E([]),
            onsubmit: !0,
            ignore: "",
            ignoreTitle: !1,
            onfocusin: function (A) {
                this.lastActive = A, this.settings.focusCleanup && !this.blockFocusCleanup && (this.settings.unhighlight && this.settings.unhighlight.call(this, A, this.settings.errorClass, this.settings.validClass), this.hideThese(this.errorsFor(A)))
            },
            onfocusout: function (A) {
                this.checkable(A) || !(A.name in this.submitted) && this.optional(A) || this.element(A)
            },
            onkeyup: function (B, A) {
                (9 !== A.which || "" !== this.elementValue(B)) && (B.name in this.submitted || B === this.lastElement) && this.element(B)
            },
            onclick: function (A) {
                A.name in this.submitted ? this.element(A) : A.parentNode.name in this.submitted && this.element(A.parentNode)
            },
            highlight: function (C, A, B) {
                "radio" === C.type ? this.findByName(C.name).addClass(A).removeClass(B) : E(C).addClass(A).removeClass(B)
            },
            unhighlight: function (C, A, B) {
                "radio" === C.type ? this.findByName(C.name).removeClass(A).addClass(B) : E(C).removeClass(A).addClass(B)
            }
        },
        setDefaults: function (A) {
            E.extend(E.validator.defaults, A)
        },
        messages: {
            required: "This field is required.",
            remote: "Please fix this field.",
            email: "Please enter a valid email address.",
            url: "Please enter a valid URL.",
            date: "Please enter a valid date.",
            dateISO: "Please enter a valid date ( ISO ).",
            number: "Please enter a valid number.",
            digits: "Please enter only digits.",
            creditcard: "Please enter a valid credit card number.",
            equalTo: "Please enter the same value again.",
            maxlength: E.validator.format("Please enter no more than {0} characters."),
            minlength: E.validator.format("Please enter at least {0} characters."),
            rangelength: E.validator.format("Please enter a value between {0} and {1} characters long."),
            range: E.validator.format("Please enter a value between {0} and {1}."),
            max: E.validator.format("输入的最大数值不能超过{0}."),
            min: E.validator.format("输入的最小数值不能超过{0}.")
        },
        autoCreateRanges: !1,
        prototype: {
            init: function () {
                function C(M) {
                    var N = E.data(this[0].form, "validator"), L = "on" + M.type.replace(/^validate/, ""),
                        K = N.settings;
                    K[L] && !this.is(K.ignore) && K[L].call(N, this[0], M)
                }

                this.labelContainer = E(this.settings.errorLabelContainer), this.errorContext = this.labelContainer.length && this.labelContainer || E(this.currentForm), this.containers = E(this.settings.errorContainer).add(this.settings.errorLabelContainer), this.submitted = {}, this.valueCache = {}, this.pendingRequest = 0, this.pending = {}, this.invalid = {}, this.reset();
                var A, B = this.groups = {};
                E.each(this.settings.groups, function (J, I) {
                    "string" == typeof I && (I = I.split(/\s/)), E.each(I, function (H, G) {
                        B[G] = J
                    })
                }), A = this.settings.rules, E.each(A, function (I, J) {
                    A[I] = E.validator.normalizeRule(J)
                }), E(this.currentForm).validateDelegate(":text, [type='password'], [type='file'], select, textarea, [type='number'], [type='search'] ,[type='tel'], [type='url'], [type='email'], [type='datetime'], [type='date'], [type='month'], [type='week'], [type='time'], [type='datetime-local'], [type='range'], [type='color'], [type='radio'], [type='checkbox']", "focusin focusout keyup", C).validateDelegate("select, option, [type='radio'], [type='checkbox']", "click", C), this.settings.invalidHandler && E(this.currentForm).bind("invalid-form.validate", this.settings.invalidHandler), E(this.currentForm).find("[required], [data-rule-required], .required").attr("aria-required", "true")
            }, form: function () {
                return this.checkForm(), E.extend(this.submitted, this.errorMap), this.invalid = E.extend({}, this.errorMap), this.valid() || E(this.currentForm).triggerHandler("invalid-form", [this]), this.showErrors(), this.valid()
            }, checkForm: function () {
                this.prepareForm();
                for (var B = 0, A = this.currentElements = this.elements(); A[B]; B++) {
                    this.check(A[B])
                }
                return this.valid()
            }, element: function (A) {
                var B = this.clean(A), C = this.validationTargetFor(B), H = !0;
                return this.lastElement = C, void 0 === C ? delete this.invalid[B.name] : (this.prepareElement(C), this.currentElements = E(C), H = this.check(C) !== !1, H ? delete this.invalid[C.name] : this.invalid[C.name] = !0), E(A).attr("aria-invalid", !H), this.numberOfInvalids() || (this.toHide = this.toHide.add(this.containers)), this.showErrors(), H
            }, showErrors: function (A) {
                if (A) {
                    E.extend(this.errorMap, A), this.errorList = [];
                    for (var B in A) {
                        this.errorList.push({message: A[B], element: this.findByName(B)[0]})
                    }
                    this.successList = E.grep(this.successList, function (C) {
                        return !(C.name in A)
                    })
                }
                this.settings.showErrors ? this.settings.showErrors.call(this, this.errorMap, this.errorList) : this.defaultShowErrors()
            }, resetForm: function () {
                E.fn.resetForm && E(this.currentForm).resetForm(), this.submitted = {}, this.lastElement = null, this.prepareForm(), this.hideErrors(), this.elements().removeClass(this.settings.errorClass).removeData("previousValue").removeAttr("aria-invalid")
            }, numberOfInvalids: function () {
                return this.objectLength(this.invalid)
            }, objectLength: function (A) {
                var B, C = 0;
                for (B in A) {
                    C++
                }
                return C
            }, hideErrors: function () {
                this.hideThese(this.toHide)
            }, hideThese: function (A) {
                A.not(this.containers).text(""), this.addWrapper(A).hide()
            }, valid: function () {
                return 0 === this.size()
            }, size: function () {
                return this.errorList.length
            }, focusInvalid: function () {
                if (this.settings.focusInvalid) {
                    try {
                        E(this.findLastActive() || this.errorList.length && this.errorList[0].element || []).filter(":visible").focus().trigger("focusin")
                    } catch (A) {
                    }
                }
            }, findLastActive: function () {
                var A = this.lastActive;
                return A && 1 === E.grep(this.errorList, function (B) {
                    return B.element.name === A.name
                }).length && A
            }, elements: function () {
                var A = this, B = {};
                return E(this.currentForm).find("input, select, textarea").not(":submit, :reset, :image, [disabled]").not(this.settings.ignore).filter(function () {
                    return !this.name && A.settings.debug && window.console && console.error("%o has no name assigned", this), this.name in B || !A.objectLength(E(this).rules()) ? !1 : (B[this.name] = !0, !0)
                })
            }, clean: function (A) {
                return E(A)[0]
            }, errors: function () {
                var A = this.settings.errorClass.split(" ").join(".");
                return E(this.settings.errorElement + "." + A, this.errorContext)
            }, reset: function () {
                this.successList = [], this.errorList = [], this.errorMap = {}, this.toShow = E([]), this.toHide = E([]), this.currentElements = E([])
            }, prepareForm: function () {
                this.reset(), this.toHide = this.errors().add(this.containers)
            }, prepareElement: function (A) {
                this.reset(), this.toHide = this.errorsFor(A)
            }, elementValue: function (A) {
                var B, C = E(A), H = A.type;
                return "radio" === H || "checkbox" === H ? E("input[name='" + A.name + "']:checked").val() : "number" === H && "undefined" != typeof A.validity ? A.validity.badInput ? !1 : C.val() : (B = C.val(), "string" == typeof B ? B.replace(/\r/g, "") : B)
            }, check: function (B) {
                B = this.validationTargetFor(this.clean(B));
                var C, M, P, R = E(B).rules(), A = E.map(R, function (G, H) {
                    return H
                }).length, N = !1, O = this.elementValue(B);
                for (M in R) {
                    P = {method: M, parameters: R[M]};
                    try {
                        if (C = E.validator.methods[M].call(this, O, B, P.parameters), "dependency-mismatch" === C && 1 === A) {
                            N = !0;
                            continue
                        }
                        if (N = !1, "pending" === C) {
                            return void (this.toHide = this.toHide.not(this.errorsFor(B)))
                        }
                        if (!C) {
                            return this.formatAndAdd(B, P), !1
                        }
                    } catch (Q) {
                        throw this.settings.debug && window.console && console.log("Exception occurred when checking element " + B.id + ", check the '" + P.method + "' method.", Q), Q
                    }
                }
                if (!N) {
                    return this.objectLength(R) && this.successList.push(B), !0
                }
            }, customDataMessage: function (A, B) {
                return E(A).data("msg" + B.charAt(0).toUpperCase() + B.substring(1).toLowerCase()) || E(A).data("msg")
            }, customMessage: function (A, B) {
                var C = this.settings.messages[A];
                return C && (C.constructor === String ? C : C[B])
            }, findDefined: function () {
                for (var A = 0; A < arguments.length; A++) {
                    if (void 0 !== arguments[A]) {
                        return arguments[A]
                    }
                }
                return void 0
            }, defaultMessage: function (A, B) {
                return this.findDefined(this.customMessage(A.name, B), this.customDataMessage(A, B), !this.settings.ignoreTitle && A.title || void 0, E.validator.messages[B], "<strong>Warning: No message defined for " + A.name + "</strong>")
            }, formatAndAdd: function (A, B) {
                var C = this.defaultMessage(A, B.method), H = /\$?\{(\d+)\}/g;
                "function" == typeof C ? C = C.call(this, B.parameters, A) : H.test(C) && (C = E.validator.format(C.replace(H, "{$1}"), B.parameters)), this.errorList.push({
                    message: C,
                    element: A,
                    method: B.method
                }), this.errorMap[A.name] = C, this.submitted[A.name] = C
            }, addWrapper: function (A) {
                return this.settings.wrapper && (A = A.add(A.parent(this.settings.wrapper))), A
            }, defaultShowErrors: function () {
                var A, B, C;
                for (A = 0; this.errorList[A]; A++) {
                    C = this.errorList[A], this.settings.highlight && this.settings.highlight.call(this, C.element, this.settings.errorClass, this.settings.validClass), this.showLabel(C.element, C.message)
                }
                if (this.errorList.length && (this.toShow = this.toShow.add(this.containers)), this.settings.success) {
                    for (A = 0; this.successList[A]; A++) {
                        this.showLabel(this.successList[A])
                    }
                }
                if (this.settings.unhighlight) {
                    for (A = 0, B = this.validElements(); B[A]; A++) {
                        this.settings.unhighlight.call(this, B[A], this.settings.errorClass, this.settings.validClass)
                    }
                }
                this.toHide = this.toHide.not(this.toShow), this.hideErrors(), this.addWrapper(this.toShow).show()
            }, validElements: function () {
                return this.currentElements.not(this.invalidElements())
            }, invalidElements: function () {
                return E(this.errorList).map(function () {
                    return this.element
                })
            }, showLabel: function (M, B) {
                var A, N, C, P = this.errorsFor(M), O = this.idOrName(M), L = E(M).attr("aria-describedby");
                P.length ? (P.removeClass(this.settings.validClass).addClass(this.settings.errorClass), P.html(B)) : (P = E("<" + this.settings.errorElement + ">").attr("id", O + "-error").addClass(this.settings.errorClass).html(B || ""), A = P, this.settings.wrapper && (A = P.hide().show().wrap("<" + this.settings.wrapper + "/>").parent()), this.labelContainer.length ? this.labelContainer.append(A) : this.settings.errorPlacement ? this.settings.errorPlacement(A, E(M)) : A.insertAfter(M), P.is("label") ? P.attr("for", O) : 0 === P.parents("label[for='" + O + "']").length && (C = P.attr("id"), L ? L.match(new RegExp("\b" + C + "\b")) || (L += " " + C) : L = C, E(M).attr("aria-describedby", L), N = this.groups[M.name], N && E.each(this.groups, function (G, H) {
                    H === N && E("[name='" + G + "']", this.currentForm).attr("aria-describedby", P.attr("id"))
                }))), !B && this.settings.success && (P.text(""), "string" == typeof this.settings.success ? P.addClass(this.settings.success) : this.settings.success(P, M)), this.toShow = this.toShow.add(P)
            }, errorsFor: function (A) {
                var B = this.idOrName(A), C = E(A).attr("aria-describedby"),
                    H = "label[for='" + B + "'], label[for='" + B + "'] *";
                return C && (H = H + ", #" + C.replace(/\s+/g, ", #")), this.errors().filter(H)
            }, idOrName: function (A) {
                return this.groups[A.name] || (this.checkable(A) ? A.name : A.id || A.name)
            }, validationTargetFor: function (A) {
                return this.checkable(A) && (A = this.findByName(A.name).not(this.settings.ignore)[0]), A
            }, checkable: function (A) {
                return /radio|checkbox/i.test(A.type)
            }, findByName: function (A) {
                return E(this.currentForm).find("[name='" + A + "']")
            }, getLength: function (A, B) {
                switch (B.nodeName.toLowerCase()) {
                    case"select":
                        return E("option:selected", B).length;
                    case"input":
                        if (this.checkable(B)) {
                            return this.findByName(B.name).filter(":checked").length
                        }
                }
                return A.length
            }, depend: function (B, A) {
                return this.dependTypes[typeof B] ? this.dependTypes[typeof B](B, A) : !0
            }, dependTypes: {
                "boolean": function (A) {
                    return A
                }, string: function (A, B) {
                    return !!E(A, B.form).length
                }, "function": function (B, A) {
                    return B(A)
                }
            }, optional: function (A) {
                var B = this.elementValue(A);
                return !E.validator.methods.required.call(this, B, A) && "dependency-mismatch"
            }, startRequest: function (A) {
                this.pending[A.name] || (this.pendingRequest++, this.pending[A.name] = !0)
            }, stopRequest: function (A, B) {
                this.pendingRequest--, this.pendingRequest < 0 && (this.pendingRequest = 0), delete this.pending[A.name], B && 0 === this.pendingRequest && this.formSubmitted && this.form() ? (E(this.currentForm).submit(), this.formSubmitted = !1) : !B && 0 === this.pendingRequest && this.formSubmitted && (E(this.currentForm).triggerHandler("invalid-form", [this]), this.formSubmitted = !1)
            }, previousValue: function (A) {
                return E.data(A, "previousValue") || E.data(A, "previousValue", {
                    old: null,
                    valid: !0,
                    message: this.defaultMessage(A, "remote")
                })
            }
        },
        classRuleSettings: {
            required: {required: !0},
            email: {email: !0},
            url: {url: !0},
            date: {date: !0},
            dateISO: {dateISO: !0},
            number: {number: !0},
            digits: {digits: !0},
            creditcard: {creditcard: !0}
        },
        addClassRules: function (A, B) {
            A.constructor === String ? this.classRuleSettings[A] = B : E.extend(this.classRuleSettings, A)
        },
        classRules: function (C) {
            var A = {}, B = E(C).attr("class");
            return B && E.each(B.split(" "), function () {
                this in E.validator.classRuleSettings && E.extend(A, E.validator.classRuleSettings[this])
            }), A
        },
        attributeRules: function (B) {
            var A, J, C = {}, L = E(B), K = B.getAttribute("type");
            for (A in E.validator.methods) {
                "required" === A ? (J = B.getAttribute(A), "" === J && (J = !0), J = !!J) : J = L.attr(A), /min|max/.test(A) && (null === K || /number|range|text/.test(K)) && (J = Number(J)), J || 0 === J ? C[A] = J : K === A && "range" !== K && (C[A] = !0)
            }
            return C.maxlength && /-1|2147483647|524288/.test(C.maxlength) && delete C.maxlength, C
        },
        dataRules: function (A) {
            var B, C, I = {}, J = E(A);
            for (B in E.validator.methods) {
                C = J.data("rule" + B.charAt(0).toUpperCase() + B.substring(1).toLowerCase()), void 0 !== C && (I[B] = C)
            }
            return I
        },
        staticRules: function (C) {
            var A = {}, B = E.data(C.form, "validator");
            return B.settings.rules && (A = E.validator.normalizeRule(B.settings.rules[C.name]) || {}), A
        },
        normalizeRules: function (A, B) {
            return E.each(A, function (C, I) {
                if (I === !1) {
                    return void delete A[C]
                }
                if (I.param || I.depends) {
                    var J = !0;
                    switch (typeof I.depends) {
                        case"string":
                            J = !!E(I.depends, B.form).length;
                            break;
                        case"function":
                            J = I.depends.call(B, B)
                    }
                    J ? A[C] = void 0 !== I.param ? I.param : !0 : delete A[C]
                }
            }), E.each(A, function (C, H) {
                A[C] = E.isFunction(H) ? H(B) : H
            }), E.each(["minlength", "maxlength"], function () {
                A[this] && (A[this] = Number(A[this]))
            }), E.each(["rangelength", "range"], function () {
                var C;
                A[this] && (E.isArray(A[this]) ? A[this] = [Number(A[this][0]), Number(A[this][1])] : "string" == typeof A[this] && (C = A[this].replace(/[\[\]]/g, "").split(/[\s,]+/), A[this] = [Number(C[0]), Number(C[1])]))
            }), E.validator.autoCreateRanges && (A.min && A.max && (A.range = [A.min, A.max], delete A.min, delete A.max), A.minlength && A.maxlength && (A.rangelength = [A.minlength, A.maxlength], delete A.minlength, delete A.maxlength)), A
        },
        normalizeRule: function (A) {
            if ("string" == typeof A) {
                var B = {};
                E.each(A.split(/\s/), function () {
                    B[this] = !0
                }), A = B
            }
            return A
        },
        addMethod: function (C, A, B) {
            E.validator.methods[C] = A, E.validator.messages[C] = void 0 !== B ? B : E.validator.messages[C], A.length < 3 && E.validator.addClassRules(C, E.validator.normalizeRule(C))
        },
        methods: {
            required: function (A, B, C) {
                if (!this.depend(C, B)) {
                    return "dependency-mismatch"
                }
                if ("select" === B.nodeName.toLowerCase()) {
                    var H = E(B).val();
                    return H && H.length > 0
                }
                return this.checkable(B) ? this.getLength(A, B) > 0 : E.trim(A).length > 0
            }, email: function (B, A) {
                return this.optional(A) || /^[a-zA-Z0-9.!#$%&'*+\/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/.test(B)
            }, url: function (B, A) {
                return this.optional(A) || /^(https?|s?ftp):\/\/(((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:)*@)?(((\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5])\.(\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5])\.(\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5])\.(\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5]))|((([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))\.)+(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))\.?)(:\d*)?)(\/((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)+(\/(([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)*)*)?)?(\?((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)|[\uE000-\uF8FF]|\/|\?)*)?(#((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)|\/|\?)*)?$/i.test(B)
            }, date: function (B, A) {
                return this.optional(A) || !/Invalid|NaN/.test(new Date(B).toString())
            }, dateISO: function (B, A) {
                return this.optional(A) || /^\d{4}[\/\-](0?[1-9]|1[012])[\/\-](0?[1-9]|[12][0-9]|3[01])$/.test(B)
            }, number: function (B, A) {
                return this.optional(A) || /^-?(?:\d+|\d{1,3}(?:,\d{3})+)?(?:\.\d+)?$/.test(B)
            }, digits: function (B, A) {
                return this.optional(A) || /^\d+$/.test(B)
            }, creditcard: function (C, B) {
                if (this.optional(B)) {
                    return "dependency-mismatch"
                }
                if (/[^0-9 \-]+/.test(C)) {
                    return !1
                }
                var A, K, L = 0, N = 0, M = !1;
                if (C = C.replace(/\D/g, ""), C.length < 13 || C.length > 19) {
                    return !1
                }
                for (A = C.length - 1; A >= 0; A--) {
                    K = C.charAt(A), N = parseInt(K, 10), M && (N *= 2) > 9 && (N -= 9), L += N, M = !M
                }
                return L % 10 === 0
            }, minlength: function (A, B, C) {
                var H = E.isArray(A) ? A.length : this.getLength(E.trim(A), B);
                return this.optional(B) || H >= C
            }, maxlength: function (A, B, C) {
                var H = E.isArray(A) ? A.length : this.getLength(E.trim(A), B);
                return this.optional(B) || C >= H
            }, rangelength: function (A, B, C) {
                var H = E.isArray(A) ? A.length : this.getLength(E.trim(A), B);
                return this.optional(B) || H >= C[0] && H <= C[1]
            }, min: function (A, B, C) {
                return this.optional(B) || A >= C
            }, max: function (A, B, C) {
                return this.optional(B) || C >= A
            }, range: function (A, B, C) {
                return this.optional(B) || A >= C[0] && A <= C[1]
            }, equalTo: function (A, B, C) {
                var H = E(C);
                return this.settings.onfocusout && H.unbind(".validate-equalTo").bind("blur.validate-equalTo", function () {
                    E(B).valid()
                }), A === H.val()
            }, remote: function (B, A, J) {
                if (this.optional(A)) {
                    return "dependency-mismatch"
                }
                var C, L, K = this.previousValue(A);
                return this.settings.messages[A.name] || (this.settings.messages[A.name] = {}), K.originalMessage = this.settings.messages[A.name].remote, this.settings.messages[A.name].remote = K.message, J = "string" == typeof J && {url: J} || J, K.old === B ? K.valid : (K.old = B, C = this, this.startRequest(A), L = {}, L[A.name] = B, E.ajax(E.extend(!0, {
                    url: J,
                    mode: "abort",
                    port: "validate" + A.name,
                    dataType: "json",
                    data: L,
                    context: C.currentForm,
                    success: function (G) {
                        var H, P, I, O = G === !0 || "true" === G;
                        C.settings.messages[A.name].remote = K.originalMessage, O ? (I = C.formSubmitted, C.prepareElement(A), C.formSubmitted = I, C.successList.push(A), delete C.invalid[A.name], C.showErrors()) : (H = {}, P = G || C.defaultMessage(A, "remote"), H[A.name] = K.message = E.isFunction(P) ? P(B) : P, C.invalid[A.name] = !0, C.showErrors(H)), K.valid = O, C.stopRequest(A, O)
                    }
                }, J)), "pending")
            }
        }
    }), E.format = function () {
        throw"$.format has been deprecated. Please use $.validator.format instead."
    };
    var F, D = {};
    E.ajaxPrefilter ? E.ajaxPrefilter(function (B, A, C) {
        var H = B.port;
        "abort" === B.mode && (D[H] && D[H].abort(), D[H] = C)
    }) : (F = E.ajax, E.ajax = function (B) {
        var C = ("mode" in B ? B : E.ajaxSettings).mode, A = ("port" in B ? B : E.ajaxSettings).port;
        return "abort" === C ? (D[A] && D[A].abort(), D[A] = F.apply(this, arguments), D[A]) : F.apply(this, arguments)
    }), E.extend(E.fn, {
        validateDelegate: function (C, A, B) {
            return this.bind(A, function (I) {
                var J = E(I.target);
                return J.is(C) ? B.apply(J, arguments) : void 0
            })
        }
    })
});
$.validator.setDefaults({
    highlight: function (B) {
        $(B).closest(".form-group").removeClass("has-success").addClass("has-error")
    }, success: function (B) {
        B.closest(".form-group").removeClass("has-error").addClass("has-success")
    }, errorElement: "span", errorClass: "help-block m-b-none"
});
$.validator.addMethod("isMobile", function (G, E) {
    var F = G.length;
    var H = /^(13[0-9]{9})|(18[0-9]{9})|(14[0-9]{9})|(17[0-9]{9})|(15[0-9]{9})$/;
    return this.optional(E) || (F == 11 && H.test(G))
}, "请正确填写您的手机号码");
$.validator.addMethod("isIntGtZero", function (D, C) {
    D = parseInt(D);
    return this.optional(C) || D > 0
}, "整数必须大于0");
$.validator.addMethod("isIntNotZero", function (D, C) {
    D = parseInt(D);
    return this.optional(C) || D != 0
}, "整数必须大于0");
$.validator.addMethod("notEqual", function (D, E, F) {
    return this.optional(E) || D != $(F).val()
}, "两个表单的内容不能相同");


$.validator.addMethod("isIdCardNo", function (D, C) {
    return this.optional(C) || isIdCardNo(D)
}, "请输入正确的身份证号码。");

function isIdCardNo(B) {
    var D = B.length, L;
    if (D == 15) {
        L = new RegExp(/^(\d{6})()?(\d{2})(\d{2})(\d{2})(\d{2})(\w)$/)
    } else {
        if (D == 18) {
            L = new RegExp(/^(\d{6})()?(\d{4})(\d{2})(\d{2})(\d{3})(\w)$/)
        } else {
            return false
        }
    }
    var K = B.match(L);
    if (K != null) {
        if (D == 15) {
            var J = new Date("19" + K[3] + "/" + K[4] + "/" + K[5]);
            var I = J.getYear() == K[3] && (J.getMonth() + 1) == K[4] && J.getDate() == K[5]
        } else {
            var J = new Date(K[3] + "/" + K[4] + "/" + K[5]);
            var I = J.getFullYear() == K[3] && (J.getMonth() + 1) == K[4] && J.getDate() == K[5]
        }
        if (!I) {
            return false
        }
    }
    if (!L.test(B)) {
        return false
    }
    return true
};

$.validator.addMethod("isCarCode", function (G, E) {
    var F = G.length;
    //var H = /^(13[0-9]{9})|(18[0-9]{9})|(14[0-9]{9})|(17[0-9]{9})|(15[0-9]{9})$/;
    var H = /^[\u4e00-\u9fa5]{1}[A-Z]{1}[A-Z_0-9]{5}$/;
    var isbool = H.test(G);
    return this.optional(E) || isbool
}, "请输入正确的汽车牌号,字母请大写");

$.validator.addMethod("maxlength", function (value, element, param) {
//当字数超过最大值后，不仅会报错而且会把多余的部分去除
    /*-------------add by wq--------------------------------*/
    //var v = $.trim(value);
    /*var v = value;
    var n = '';
    var b = 0;
    for (var i = 0; i < v.length; i++) {
        var c = v.slice(i, i + 1);
        if (b <= param) {
            n += c;
        }
        b++;
    }
    $(element).val(n);*/
    return this.optional(element) || zw_strlen(value) <= param;//截取符合的字数

}, "字数超长");


//中文字符长度
function zw_strlen(str){
    var len = 0;
    for (var i=0; i<str.length; i++) {
        var c = str.charCodeAt(i);
        //单字节加1
        if ((c >= 0x0001 && c <= 0x007e) || (0xff60<=c && c<=0xff9f)) {
            len++;
        }
        else {
            len+=2;
        }
    }
    return len;
}